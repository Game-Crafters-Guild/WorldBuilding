// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SeedJumpFlood
#pragma kernel JumpFlood
#pragma kernel SdfFromJumpFlood
#pragma kernel InvertBlackWhite

Texture2D Input;
RWTexture2D<float4> Result;
uniform float2 TextureSize;
uniform int StepSize;

static int2 offsets[] = {
    int2(-1, -1),
    int2(+0, -1),
    int2(+1, -1),
    int2(-1, -0),
    int2(+0, -0),
    int2(+1, -0),
    int2(-1, +1),
    int2(+0, +1),
    int2(+1, +1)
};

[numthreads(8,8,1)]
void InvertBlackWhite (uint3 id : SV_DispatchThreadID)
{
    float4 myColor = Input.Load(int3(id.xy, 0));
    Result[id.xy] = float4(1, 1, 1, 1) - myColor;
}

[numthreads(8,8,1)]
void SeedJumpFlood (uint3 id : SV_DispatchThreadID)
{
    float4 myColor = Input.Load(int3(id.xy, 0));
    if (myColor.a >= 0.5) {
        Result[id.xy] = float4(id.xy / TextureSize, 0, 1);
        return;    
    }

    for (int i = 0; i < 8; i++) {
        float2 offset = id.xy + offsets[i] * StepSize;
        float4 sample = Input.Load(int3(offset, 0));
        if (sample.a >= 0.5) {
            Result[id.xy] = float4(offset / TextureSize, 0, 1);
            return;
        }
    }
    Result[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(8,8,1)]
void JumpFlood (uint3 id : SV_DispatchThreadID)
{
    float closestDistance = 10000;
    float4 closestValue = float4(0, 0, 0, 0);
    for (int y = -1; y <= 1; y++)
    {
        for (int x = -1; x <= 1; x++)
        {
            int2 offsets = int2(x * StepSize, y * StepSize);
            int2 uv = id.xy + offsets.xy;
            float4 sample = Input.Load(int3(uv, 0));
            if (sample.a >= 0.5)
            {
                float distanceToPos = distance(id.xy / TextureSize, sample.xy);
                if (distanceToPos < closestDistance) {
                    closestDistance = distanceToPos;    
                    closestValue = sample;
                }
            }
        }
    }
    Result[id.xy] = closestValue;
}


RWStructuredBuffer<uint> furthestDistance;
[numthreads(8,8,1)]
void SdfFromJumpFlood (uint3 id : SV_DispatchThreadID)
{
    uint closestDistance = 1000000000;
    for (int y = -1; y <= 1; y++)
    {
        for (int x = -1; x <= 1; x++)
        {
            int2 offsets = int2(x * StepSize, y * StepSize);
            int2 uv = id.xy + offsets.xy;
            float4 sample = Input.Load(int3(uv, 0));
            if (sample.a >= 0.5)
            {
                int2 toSample = id.xy - (sample.xy * TextureSize);
                uint distanceSq = toSample.x * toSample.x + toSample.y * toSample.y;
                if (distanceSq < closestDistance) {
                    closestDistance = distanceSq;
                }
            }
        }
    }
    InterlockedMax(furthestDistance[0], closestDistance);
    AllMemoryBarrier();
    
    Result[id.xy] = sqrt((float)closestDistance) / sqrt((float)furthestDistance[0]);
}
