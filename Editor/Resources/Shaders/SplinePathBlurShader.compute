#pragma kernel CSBlurMask

Texture2D<float4> Source;
RWTexture2D<float4> Result;

// Controls the blur strength/radius
int _BlurStrength;

// Flag for handling straight lines specially
int _IsStraightLine;

[numthreads(8,8,1)]
void CSBlurMask(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Source.GetDimensions(width, height);
    
    // Skip if out of bounds
    if (id.x >= width || id.y >= height)
        return;
    
    // Apply a weighted blur with safer bounds checking
    int kBlurRadius = min(max(1, _BlurStrength), 10); // Limit radius to avoid excessive sampling
    
    // For straight lines, we can increase the blur radius a bit more 
    // to ensure the line is visible
    if (_IsStraightLine > 0)
    {
        kBlurRadius = min(kBlurRadius + 2, 10);
    }
    
    float4 sum = float4(0, 0, 0, 0);
    float totalWeight = 0;
    
    // Sigma value for Gaussian - related to blur strength
    float sigma = kBlurRadius * 0.5;
    float twoSigmaSq = 2.0 * sigma * sigma;
    
    // Sample within safe bounds
    for (int y = -kBlurRadius; y <= kBlurRadius; y++)
    {
        for (int x = -kBlurRadius; x <= kBlurRadius; x++)
        {
            int2 samplePos = int2(id.xy) + int2(x, y);
            
            // Strict bounds checking to prevent sampling outside texture
            if (samplePos.x < 0 || samplePos.y < 0 || samplePos.x >= width || samplePos.y >= height)
                continue;
            
            // Weight calculation (true Gaussian)
            float distSq = float(x * x + y * y);
            
            // For straight lines, we can adjust the weight calculation to 
            // favor certain directions (particularly perpendicular to the line)
            // This helps make the line more visible
            float weight = exp(-distSq / twoSigmaSq);
            
            // For straight lines, bias toward dilating the edges
            if (_IsStraightLine > 0 && distSq <= 4)
            {
                weight *= 1.5; // Boost the weight of nearby pixels
            }
            
            float4 pixelColor = Source[samplePos];
            sum += pixelColor * weight;
            totalWeight += weight;
        }
    }
    
    // Avoid division by zero
    float4 result = totalWeight > 0.0001 ? sum / totalWeight : Source[id.xy];
    
    // Get original pixel safely
    float4 original = Source[id.xy];
    
    // Additional intensity-preserving smoothing for alpha channel
    if (original.a > 0.01)
    {
        // For straight lines, preserve alpha more aggressively
        if (_IsStraightLine > 0)
        {
            result.a = max(result.a, original.a * 0.85);
            
            // Also ensure some minimum alpha to make the line visible
            result.a = max(result.a, 0.05);
        }
        else
        {
            result.a = max(result.a, original.a * 0.7);
        }
    }
    else if (_IsStraightLine > 0)
    {
        // For straight lines, if we see any non-zero alpha in the neighborhood,
        // ensure this pixel has some minimal alpha too
        if (sum.a > 0.01)
        {
            result.a = max(result.a, 0.03);
        }
    }
    
    Result[id.xy] = result;
} 