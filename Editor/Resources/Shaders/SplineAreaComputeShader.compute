#pragma kernel CSCreateSplineAreaMask
#pragma kernel CSCalculateNormalizedDistances
#pragma kernel CSBlurSDF

RWTexture2D<float4> Result;
RWStructuredBuffer<float3> SplinePositions;
RWStructuredBuffer<uint> furthestDistance;
uniform int NumPositions;
uniform float4 RegionMin;
uniform float4 RegionSize;

#include "Packages/com.unity.splines/Shader/Spline.cginc"

#pragma kernel EvaluateSplinePositions

SplineInfo info = float4(0,0,0,0);
StructuredBuffer<BezierCurve> curves;
StructuredBuffer<float> curveLengths;

[numthreads(64,1,1)]
void EvaluateSplinePositions (uint id : SV_DispatchThreadID)
{
    float curve = SplineToCurveT(info, curveLengths, id/(float)(NumPositions - 1));
    SplinePositions[id] = EvaluatePosition(curves[floor(curve) % GetKnotCount(info)], frac(curve)); 
}



float3 GetPointInSegment(float3 position, float3 p0, float3 p1)
{
    float3 v = p1 - p0;
    float3 w = position - p0;

    float c1 = dot(w,v);
    if ( c1 <= 0 )   // the closest point is outside the segment and nearer to P0
        return p0;

    float c2 = dot(v,v);
    if ( c2 <= c1 )  // the closest point is outside the segment and nearer to P1
        return p1;

    float b = c1 / c2;
    float3 Pb = p0 + b * v;
    return Pb;
}

float GetDistanceToSegment(float3 position, float3 p0, float3 p1)
{
    float3 closestPointInSegment = GetPointInSegment(position, p0, p1);
    float2 toSample = position.xz - closestPointInSegment.xz;
    float distanceSq = toSample.x * toSample.x + toSample.y * toSample.y;
    return sqrt(distanceSq);
}

bool IsPointInsidePolygon(float3 position, out float distance)
{
    uint intersections = 0;
    int vertexCount = NumPositions;
    float closestDistance = 1000000000;
 
    // Iterate over each edge of the polygon
    for (int i = 0, j = vertexCount - 1; i < vertexCount; j = i++)
    {
        float3 vertex1 = SplinePositions[i];
        float3 vertex2 = SplinePositions[j];
        vertex1.y = 0.0;
        vertex2.y = 0.0;

        float distanceToSegment = GetDistanceToSegment(position, vertex1, vertex2);
        if (distanceToSegment < closestDistance) {
            closestDistance = distanceToSegment;
        }
 
        // Check if the edge crosses the horizontal ray originating from the point
        bool crossesRay = (vertex1.z > position.z) != (vertex2.z > position.z);
 
        if (crossesRay)
        {
            // Calculate the x-coordinate of the intersection point
            float intersectionX = vertex2.x - (vertex2.z - position.z) * (vertex2.x - vertex1.x) / (vertex2.z - vertex1.z);
 
            // Count the intersection if the x-coordinate is to the right of the point
            if (position.x < intersectionX)
            {
                intersections++;
            }
        }
    }
    // Odd number of intersections means the point is inside
    distance = closestDistance;
    return intersections % 2 != 0;
}

[numthreads(8,8,1)]
void CSCreateSplineAreaMask(uint3 id : SV_DispatchThreadID)
{
    uint outputTextureWidth;
    uint outputTextureHeight;
    Result.GetDimensions(outputTextureWidth, outputTextureHeight);
    float2 uv = id.xy / float2(outputTextureWidth, outputTextureHeight);
    float3 position = float3(RegionMin.x + uv.x * RegionSize.x, 0.0f, RegionMin.z + uv.y * RegionSize.z);
    float distance = 0;
    bool isInSpline = IsPointInsidePolygon(position, distance);

    if (!isInSpline)
    {
        distance = 0;
    }
    uint distanceSq = (distance * distance) * 10000;
    InterlockedMax(furthestDistance[0], distanceSq);
    distance = distance / max(RegionSize.x, RegionSize.z);
    Result[id.xy] = isInSpline ? float4(distance, distance, 0.0f, distance) : float4(0.0f, 0.0f, 0.0f, 0.0f);
}

[numthreads(8,8,1)]
void CSCalculateNormalizedDistances (uint3 id : SV_DispatchThreadID)
{
    float distance = saturate((Result[id.xy].x * max(RegionSize.x, RegionSize.z)) / sqrt((float)furthestDistance[0] / 10000.0f));
    Result[id.xy] = float4(distance, distance, 0.0f, distance);
}

Texture2D<float4> SDF;
[numthreads(8,8,1)]
void CSBlurSDF(uint3 id : SV_DispatchThreadID)
{
    const int kBlurSize = 3;
    float total = 0.0;
    float count = 0;
    for (int x = -kBlurSize; x <= kBlurSize; x++)
    {
        for (int y = -kBlurSize; y <= kBlurSize; y++)
        {
            int3 pos = int3(id.x + x, id.y + y, 0);
            total += SDF.Load(pos).x;
            count += 1;
        }
    }
    float average = total / count;
    Result[id.xy] = float4(average, average, 0.0f, average);
}

