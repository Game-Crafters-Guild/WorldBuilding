// Compute shader for game object placement with constraints
#pragma kernel GeneratePositions
#pragma kernel FilterObjectCollisions

// Input terrain parameters
float4 _TerrainParams; // x: width, y: height, z: length, w: unused
float4 _TerrainPosition; // x, y, z position of terrain 
float2 _HeightmapResolution; // x: width, y: height

// Bounds parameters
float4 _BoundsMin; // x, z: normalized bounds min, y, w: unused
float4 _BoundsMax; // x, z: normalized bounds max, y, w: unused

// Object placement parameters
float _Density;
uint _MaxObjectCount;
uint _NumberOfGameObjects;
uint _RandomSeed;
float _RandomOffset;

// Grid-based placement parameters
int _GridWidth;
int _GridDepth;
int _ObjectsPerSquareUnit;

// Prefab-specific settings
struct PrefabSettings
{
    float minScale;
    float maxScale;
    float yOffset;
    uint alignToNormal;
    uint randomYRotation;
    float minRotation;
    float maxRotation;
    float minimumDistance;
};
StructuredBuffer<PrefabSettings> _PrefabSettings;

// Buffers for constraints
StructuredBuffer<float2> _HeightConstraints; // x: min height, y: max height
StructuredBuffer<float2> _SlopeConstraints; // x: min angle, y: max angle
StructuredBuffer<float4> _NoiseConstraints; // x: threshold, y: scale, z: offset, w: unused
StructuredBuffer<float> _MaskConstraintThresholds; // threshold values for mask constraints
StructuredBuffer<int> _LayerConstraintIndices; // Indices of allowed terrain layers
uint _LayerConstraintCount; // Number of allowed terrain layers (0 means no constraint)
StructuredBuffer<float> _PlacedObjectPositions; // xyz positions of already placed objects
StructuredBuffer<float> _MinimumDistances; // Minimum distance for each placed object
uint _PlacedObjectCount;
float _DefaultMinDistance;

// Texture samplers
Texture2D<float4> _AlphamapTexture;
SamplerState sampler_AlphamapTexture;
Texture2D<float4> _MaskTexture;
SamplerState sampler_MaskTexture;
Texture2D<float> _HeightmapTexture;
SamplerState sampler_HeightmapTexture;
Texture2D<float4> _NormalTexture;
SamplerState sampler_NormalTexture;
Texture2D<float4> _NoiseTexture;
SamplerState sampler_NoiseTexture;

// Output buffer for positions
struct PlacementResult 
{
    float3 position;    // x, y, z world space position
    float scale;        // uniform scale factor
    float rotation;     // rotation around Y axis in degrees
    uint prefabIndex;   // index of the prefab to spawn
    uint isValid;       // 1 if valid position, 0 if not
};

// Buffers for filter pass
RWStructuredBuffer<PlacementResult> _Results;
RWStructuredBuffer<PlacementResult> _FilteredResults;
RWStructuredBuffer<int> _ValidCount;
int _MaxResults;
int _InputResultsCount;

// Helper functions
float GetRandomFloat(uint id, uint seed)
{
    // Simple hash function
    uint state = id ^ seed;
    state = state * 747796405 + 2891336453;
    state = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    state = (state >> 22) ^ state;
    return frac(state / 4294967296.0);
}

float2 GetRandomPosition(uint id)
{
    // Instead of using sequential grid cells, use a hash-based approach
    // to distribute objects more evenly across the entire grid
    uint hashedId = id;
    
    // Simple hash based on Wang hash
    hashedId = (hashedId ^ 61) ^ (hashedId >> 16);
    hashedId = hashedId + (hashedId << 3);
    hashedId = hashedId ^ (hashedId >> 4);
    hashedId = hashedId * 0x27d4eb2d;
    hashedId = hashedId ^ (hashedId >> 15);
    
    // Calculate total grid cells
    uint totalGridCells = _GridWidth * _GridDepth;
    
    // Early exit if grid has no cells
    if (totalGridCells == 0)
        return float2(0, 0);
    
    // Get a cell ID that's distributed across the entire grid
    uint gridCellId = hashedId % totalGridCells;
    
    // Calculate grid x, y coordinates
    uint gridX = gridCellId % _GridWidth;
    uint gridY = gridCellId / _GridWidth;
    
    // Calculate normalized bounds width and height
    float boundsWidth = _BoundsMax.x - _BoundsMin.x;
    float boundsHeight = _BoundsMax.z - _BoundsMin.z;
    
    // Calculate cell size in normalized coordinates
    float cellWidth = boundsWidth / _GridWidth;
    float cellHeight = boundsHeight / _GridDepth;
    
    // Calculate base position of this grid cell
    float baseX = _BoundsMin.x + gridX * cellWidth;
    float baseY = _BoundsMin.z + gridY * cellHeight;
    
    // Get randomization within this cell
    uint localId = id % _ObjectsPerSquareUnit;
    float randX = GetRandomFloat(gridCellId * 1000 + localId * 2, _RandomSeed);
    float randY = GetRandomFloat(gridCellId * 1000 + localId * 2 + 1, _RandomSeed);
    
    // Final position within the cell
    float2 position;
    position.x = baseX + randX * cellWidth;
    position.y = baseY + randY * cellHeight;
    
    // Apply random offset if needed
    if (_RandomOffset > 0)
    {
        float2 offsetScale = float2(cellWidth, cellHeight) * _RandomOffset;
        float2 offset;
        offset.x = (GetRandomFloat(gridCellId * 1000 + localId * 4 + 2, _RandomSeed) * 2 - 1) * offsetScale.x;
        offset.y = (GetRandomFloat(gridCellId * 1000 + localId * 4 + 3, _RandomSeed) * 2 - 1) * offsetScale.y;
        
        position += offset;
        
        // Clamp to bounds
        position.x = clamp(position.x, _BoundsMin.x, _BoundsMax.x);
        position.y = clamp(position.y, _BoundsMin.z, _BoundsMax.z);
    }
    
    // Ensure we're within terrain bounds (0-1)
    position.x = clamp(position.x, 0, 1);
    position.y = clamp(position.y, 0, 1);
    
    return position;
}

float GetTerrainHeight(float2 normPos)
{
    return _HeightmapTexture.SampleLevel(sampler_HeightmapTexture, normPos, 0).r * _TerrainParams.y * 2.0;
}

float3 GetTerrainNormal(float2 normPos)
{
    float3 normal = _NormalTexture.SampleLevel(sampler_NormalTexture, normPos, 0).xyz;
    return normalize(normal * 2 - 1); // Convert from 0-1 to -1-1 range
}

float GetTerrainSlope(float2 normPos)
{
    float3 normal = GetTerrainNormal(normPos);
    return degrees(acos(dot(normal, float3(0, 1, 0))));
}

bool CheckHeightConstraint(float height, uint constraintIndex)
{
    float2 constraint = _HeightConstraints[constraintIndex];
    return height >= constraint.x && height <= constraint.y;
}

bool CheckSlopeConstraint(float slope, uint constraintIndex)
{
    float2 constraint = _SlopeConstraints[constraintIndex];
    return slope >= constraint.x && slope <= constraint.y;
}

bool CheckMaskConstraint(float2 boundsNorm)
{
    float4 maskColor = _MaskTexture.SampleLevel(sampler_MaskTexture, boundsNorm, 0);
    
    // Use the actual threshold from MaskConstraint
    float maskValue = maskColor.r;
    
    // Compare with the threshold from the constraint
    return maskValue > _MaskConstraintThresholds[0];
}

bool CheckNoiseConstraint(float2 boundsNorm)
{
    // Get noise parameters
    float4 noiseParams = _NoiseConstraints[0]; // x: threshold, y: scale, z: offset, w: unused
    
    // Sample the noise texture
    float4 noiseColor = _NoiseTexture.SampleLevel(sampler_NoiseTexture, boundsNorm, 0);
    
    // Use grayscale value for comparison (average of RGB)
    float noiseValue = (noiseColor.r + noiseColor.g + noiseColor.b) / 3.0;
    
    // Fall back to procedural noise if the texture returns a zero value (might be a default white texture)
    if (noiseValue < 0.001f)
    {
        // Simple Perlin-like noise as fallback
        float2 scaledPos = boundsNorm * noiseParams.y + float2(noiseParams.z, noiseParams.z);
        float2 i = floor(scaledPos);
        float2 f = frac(scaledPos);
        float2 u = f * f * (3.0 - 2.0 * f); // Smoothstep
        
        float n00 = frac(sin(dot(i, float2(127.1, 311.7))) * 43758.5453);
        float n01 = frac(sin(dot(i + float2(0, 1), float2(127.1, 311.7))) * 43758.5453);
        float n10 = frac(sin(dot(i + float2(1, 0), float2(127.1, 311.7))) * 43758.5453);
        float n11 = frac(sin(dot(i + float2(1, 1), float2(127.1, 311.7))) * 43758.5453);
        
        float nx0 = lerp(n00, n10, u.x);
        float nx1 = lerp(n01, n11, u.x);
        noiseValue = lerp(nx0, nx1, u.y);
    }
    
    // Check against threshold
    return noiseValue >= noiseParams.x;
}

bool CheckCollisionConstraint(float3 worldPos, float currentMinDistance, float objectScale)
{
    // If no placed objects, constraint is satisfied
    if (_PlacedObjectCount == 0)
        return true;
    
    // Use default if not specified
    float minDist = currentMinDistance > 0 ? currentMinDistance : _DefaultMinDistance;
    
    // Scale the minimum distance by the object's scale
    minDist *= objectScale;
    
    // Check against all placed objects
    for (uint p = 0; p < _PlacedObjectCount; p++)
    {
        // Get position from flattened array
        float3 objPos = float3(
            _PlacedObjectPositions[p*3],
            _PlacedObjectPositions[p*3+1],
            _PlacedObjectPositions[p*3+2]
        );
        
        // Get minimum distance for this object (already includes GlobalScale and that object's scale)
        float objMinDist = _MinimumDistances[p];
        
        // Use maximum of the two distances
        float requiredDist = max(minDist, objMinDist);
        
        // Calculate distance between points
        float dist = distance(worldPos, objPos);
        
        // If too close, fail the constraint
        if (dist < requiredDist)
            return false;
    }
    
    // All checks passed
    return true;
}

bool CheckLayerConstraint(float2 normPos)
{
    // If no layer constraints are specified, always return true
    if (_LayerConstraintCount == 0)
        return true;
    
    // Special case: if we have one entry and it's -1, it means the user specified
    // layer constraints but none of those layers were found in the terrain.
    // In this case, we should always fail the constraint
    if (_LayerConstraintCount == 1 && _LayerConstraintIndices[0] == -1)
        return false;
    
    // Sample alphamap at position
    float4 alphamap = _AlphamapTexture.SampleLevel(sampler_AlphamapTexture, normPos, 0);
    
    // Find the dominant layer index (0-3 for RGBA channels)
    int dominantLayerIndex = 0;
    float maxWeight = alphamap.r;
    
    if (alphamap.g > maxWeight) { 
        dominantLayerIndex = 1; 
        maxWeight = alphamap.g; 
    }
    if (alphamap.b > maxWeight) { 
        dominantLayerIndex = 2; 
        maxWeight = alphamap.b; 
    }
    if (alphamap.a > maxWeight) { 
        dominantLayerIndex = 3; 
        maxWeight = alphamap.a; 
    }
    
    // Check if the dominant layer is in our allowed layers
    for (uint k = 0; k < _LayerConstraintCount; k++)
    {
        if (_LayerConstraintIndices[k] == dominantLayerIndex)
            return true;
    }
    
    return false;
}

bool CheckAllConstraints(float2 normPos, float2 boundsNorm, float height, float slope, float3 worldPos, float minDistance, float objectScale)
{
    // Check mask constraint if texture provided
    if (!CheckMaskConstraint(boundsNorm))
        return false;
    
    // Check height constraints
    if (!CheckHeightConstraint(height, 0))
        return false;
    
    // Check slope constraints
    if (!CheckSlopeConstraint(slope, 0))
        return false;
    
    // Check noise constraints
    if (!CheckNoiseConstraint(boundsNorm))
        return false;
    
    // Check layer constraint
    if (!CheckLayerConstraint(normPos))
        return false;
    
    // Check collision constraint with object scale
    if (!CheckCollisionConstraint(worldPos, minDistance, objectScale))
        return false;
    
    return true;
}

[numthreads(64,1,1)]
void GeneratePositions(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    // Initialize result as invalid
    _Results[index].isValid = 0;
    
    // Skip if beyond the maximum number of objects
    if (_MaxObjectCount > 0 && index >= _MaxObjectCount)
        return;
    
    // Apply density-based filtering only if density is less than 1.0
    // With higher object counts and two-pass filtering, we can be less aggressive here
    if (_Density < 0.99f && GetRandomFloat(index * 13 + 9, _RandomSeed) > _Density)
        return;
    
    // Generate grid-based random position with hashing for better distribution
    float2 normPos = GetRandomPosition(index);
    
    // Skip if position is invalid (outside grid)
    if (normPos.x == 0 && normPos.y == 0 && _GridWidth > 0 && _GridDepth > 0)
        return;
    
    // Calculate position within bounds (0-1 relative to bounds, not terrain)
    float2 boundsNorm;
    
    // Calculate the aspect ratio of the bounds
    float boundsWidth = _BoundsMax.x - _BoundsMin.x;
    float boundsDepth = _BoundsMax.z - _BoundsMin.z;
    
    // Adjust for square aspect ratio (matching SplineAreaShape's adjustment)
    if (boundsWidth > boundsDepth)
    {
        // X is dominant, so we need to scale Z to match
        float center = (_BoundsMin.z + _BoundsMax.z) * 0.5;
        float halfSize = boundsWidth * 0.5;
        
        // Map Y (Z) coordinate properly to match the square aspect in the mask
        boundsNorm.x = (normPos.x - _BoundsMin.x) / boundsWidth;
        boundsNorm.y = (normPos.y - (center - halfSize)) / boundsWidth;
    }
    else
    {
        // Z is dominant, so we need to scale X to match
        float center = (_BoundsMin.x + _BoundsMax.x) * 0.5;
        float halfSize = boundsDepth * 0.5;
        
        // Map X coordinate properly to match the square aspect in the mask
        boundsNorm.x = (normPos.x - (center - halfSize)) / boundsDepth;
        boundsNorm.y = (normPos.y - _BoundsMin.z) / boundsDepth;
    }
    
    // Clamp to 0-1 range to ensure valid texture coordinates
    boundsNorm = clamp(boundsNorm, 0.0, 1.0);
    
    // Get terrain height and slope
    float height = GetTerrainHeight(normPos);
    float slope = GetTerrainSlope(normPos);
    
    // Choose prefab index
    uint prefabIndex = floor(GetRandomFloat(index * 7 + 5, _RandomSeed) * _NumberOfGameObjects);
    if (prefabIndex >= _NumberOfGameObjects)
        prefabIndex = _NumberOfGameObjects - 1;
    
    // Get prefab-specific settings
    PrefabSettings settings = _PrefabSettings[prefabIndex];
    
    // Convert normalized to world position with Y offset
    float3 worldPos;
    worldPos.x = _TerrainPosition.x + normPos.x * _TerrainParams.x;
    worldPos.y = height + settings.yOffset;
    worldPos.z = _TerrainPosition.z + normPos.y * _TerrainParams.z;
    
    // Calculate random scale based on prefab settings
    float scale = lerp(settings.minScale, settings.maxScale, GetRandomFloat(index * 9 + 6, _RandomSeed));
    
    // Check all constraints with object-specific minimum distance and scale
    if (CheckAllConstraints(normPos, boundsNorm, height, slope, worldPos, settings.minimumDistance, scale))
    {
        // Store valid result
        _Results[index].position = worldPos;
        _Results[index].scale = scale;
        _Results[index].rotation = 0;
        if (settings.randomYRotation > 0)
        {
            _Results[index].rotation = lerp(settings.minRotation, settings.maxRotation, GetRandomFloat(index * 11 + 7, _RandomSeed));
        }
        _Results[index].prefabIndex = prefabIndex;
        _Results[index].isValid = 1;
    }
}

// Kernel for filtering object collisions
[numthreads(64,1,1)]
void FilterObjectCollisions(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    // Skip if beyond input results count
    if (index >= _InputResultsCount)
        return;
    
    // Skip invalid objects
    if (_Results[index].isValid == 0)
        return;
    
    // Get this object's position, scale, and prefab index
    float3 position = _Results[index].position;
    float scale = _Results[index].scale;
    uint prefabIndex = _Results[index].prefabIndex;
    
    // Get minimum distance for this object
    PrefabSettings settings = _PrefabSettings[prefabIndex];
    float minDist = settings.minimumDistance;
    if (minDist <= 0)
        minDist = _DefaultMinDistance;
    
    // Scale the minimum distance by the object's scale, slightly reduced for the filtering pass
    // to make filtering less aggressive
    minDist *= scale * 0.8; // Reduce by 20% to prevent over-filtering
    
    // Check against all other valid objects we've seen so far
    bool validPosition = true;
    
    // First, check against existing objects (from previous iterations)
    // This is already done in the GeneratePositions kernel via CheckCollisionConstraint
    
    // Next, check against other objects already in the filtered results buffer
    uint validCount = 0;
    InterlockedAdd(_ValidCount[0], 0, validCount); // Atomic read of current valid count
    
    // Early exit for the first object (always valid and nothing to check against)
    if (validCount == 0)
    {
        // This is the first valid object, add it
        uint slotIndex = 0;
        InterlockedAdd(_ValidCount[0], 1, slotIndex);
        
        if (slotIndex < _MaxResults)
        {
            _FilteredResults[slotIndex] = _Results[index];
        }
        return;
    }
    
    // Check against previously filtered objects
    for (uint j = 0; j < validCount && validPosition; j++)
    {
        // Skip if the other object is invalid (should not happen, but just in case)
        if (_FilteredResults[j].isValid == 0)
            continue;
            
        // Get the other object's position, scale, and minimum distance
        float3 otherPos = _FilteredResults[j].position;
        float otherScale = _FilteredResults[j].scale;
        uint otherPrefabIndex = _FilteredResults[j].prefabIndex;
        
        // Skip distance check for far away objects (optimization)
        float3 diff = position - otherPos;
        float sqrDist = dot(diff, diff);
        if (sqrDist > 100.0) // Skip if more than 10 units away
            continue;
        
        // Get other object's minimum distance
        PrefabSettings otherSettings = _PrefabSettings[otherPrefabIndex];
        float otherMinDist = otherSettings.minimumDistance;
        if (otherMinDist <= 0)
            otherMinDist = _DefaultMinDistance;
            
        // Scale by object's scale, also reduced for filtering pass
        otherMinDist *= otherScale * 0.8; // Reduce by 20% 
        
        // Use maximum of the two distances
        float requiredDist = max(minDist, otherMinDist);
        
        // Calculate squared distance for performance
        float sqrRequiredDist = requiredDist * requiredDist;
        
        // Check distance
        if (sqrDist < sqrRequiredDist)
        {
            validPosition = false;
        }
    }
    
    // If position is valid, add to filtered results
    if (validPosition)
    {
        // Atomically increment valid count to get our "slot"
        uint slotIndex = 0;
        InterlockedAdd(_ValidCount[0], 1, slotIndex);
        
        // Check if we're still under the max objects limit
        if (slotIndex < _MaxResults)
        {
            // Copy result to filtered array
            _FilteredResults[slotIndex] = _Results[index];
        }
    }
} 