// Compute shader for game object placement with constraints
#pragma kernel GeneratePositions
#pragma kernel FilterObjectCollisions

// Input terrain parameters
float4 _TerrainParams; // x: width, y: height, z: length, w: unused
float4 _TerrainPosition; // x, y, z position of terrain 
float2 _HeightmapResolution; // x: width, y: height

// Bounds parameters
float4 _BoundsMin; // x, z: normalized bounds min (clamped to 0-1), y, w: unused
float4 _BoundsMax; // x, z: normalized bounds max (clamped to 0-1), y, w: unused
float4 _OriginalBoundsMin; // x, z: normalized bounds min (unclamped), y, w: unused  
float4 _OriginalBoundsMax; // x, z: normalized bounds max (unclamped), y, w: unused

// Object placement parameters
float _Density;
uint _MaxObjectCount;
uint _NumberOfGameObjects;
uint _RandomSeed;
float _RandomOffset;

// Grid-based placement parameters
int _GridWidth;
int _GridDepth;
int _ObjectsPerSquareUnit;

// Prefab-specific settings
struct PrefabSettings
{
    float minScale;
    float maxScale;
    float yOffset;
    uint alignToNormal;
    uint randomYRotation;
    float minRotation;
    float maxRotation;
    float minimumDistance;
    float minNormalAlignment; // 0-1 value for minimum normal alignment
    float maxNormalAlignment; // 0-1 value for maximum normal alignment
};
StructuredBuffer<PrefabSettings> _PrefabSettings;

// Buffers for constraints
StructuredBuffer<float2> _HeightConstraints; // x: min height, y: max height
StructuredBuffer<float2> _SlopeConstraints; // x: min angle, y: max angle
StructuredBuffer<float4> _NoiseConstraints; // x: threshold, y: scale, z: offset, w: unused
StructuredBuffer<float> _MaskConstraintThresholds; // threshold values for mask constraints
StructuredBuffer<int> _LayerConstraintIndices; // Indices of allowed terrain layers
uint _LayerConstraintCount; // Number of allowed terrain layers (0 means no constraint)
StructuredBuffer<float> _PlacedObjectPositions; // xyz positions of already placed objects
StructuredBuffer<float> _MinimumDistances; // Minimum distance for each placed object
uint _PlacedObjectCount;
float _DefaultMinDistance;

// Texture samplers
Texture2D<float4> _AlphamapTexture;
SamplerState sampler_AlphamapTexture;
Texture2D<float4> _MaskTexture;
SamplerState sampler_MaskTexture;
Texture2D<float> _HeightmapTexture;
SamplerState sampler_HeightmapTexture;
Texture2D<float4> _NormalTexture;
SamplerState sampler_NormalTexture;
Texture2D<float4> _NoiseTexture;
SamplerState sampler_NoiseTexture;

// Output buffer for positions
struct PlacementResult 
{
    float3 position;    // x, y, z world space position (12 bytes)
    float scale;        // uniform scale factor (4 bytes)
    float rotation;     // rotation around Y axis in degrees (4 bytes)
    uint prefabIndex;   // index of the prefab to spawn (4 bytes)
    uint isValid;       // 1 if valid position, 0 if not (4 bytes)
    float normalAlignmentFactor; // How much to align to normal (0-1) (4 bytes)
    float3 normal;      // Surface normal at this point (12 bytes)
    // Total: 44 bytes
};

// Buffers for filter pass
RWStructuredBuffer<PlacementResult> _Results;
RWStructuredBuffer<PlacementResult> _FilteredResults;
RWStructuredBuffer<int> _ValidCount;
int _MaxResults;
int _InputResultsCount;

// Helper functions
float GetRandomFloat(uint id, uint seed)
{
    // Simple hash function
    uint state = id ^ seed;
    state = state * 747796405 + 2891336453;
    state = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    state = (state >> 22) ^ state;
    return frac(state / 4294967296.0);
}

float2 GetRandomPosition(uint id)
{
    // Instead of using sequential grid cells, use a hash-based approach
    // to distribute objects more evenly across the entire grid
    uint hashedId = id;
    
    // Simple hash based on Wang hash - only use thread ID and seed for hashing
    hashedId = (hashedId ^ _RandomSeed) * 0x27d4eb2d;
    hashedId = (hashedId ^ 61) ^ (hashedId >> 16);
    hashedId = hashedId + (hashedId << 3);
    hashedId = hashedId ^ (hashedId >> 4);
    hashedId = hashedId * 0x27d4eb2d;
    hashedId = hashedId ^ (hashedId >> 15);
    
    // Calculate total grid cells
    uint totalGridCells = _GridWidth * _GridDepth;
    
    // Early exit if grid has no cells
    if (totalGridCells == 0)
        return float2(0, 0);
    
    // Get a cell ID that's distributed across the entire grid
    // Use a deterministic hash of the original ID for the cell selection
    uint gridCellId = hashedId % totalGridCells;
    
    // Hash the grid cell ID with the seed to get a reproducible cell position
    // This ensures consistency even if gridCellId is the same but in a different location
    uint hashedCellId = gridCellId ^ _RandomSeed;
    hashedCellId = hashedCellId * 1664525 + 1013904223; // Linear congruential generator

    // Calculate grid x, y coordinates based on hashed cell ID 
    // This makes the cell positions more random but still deterministic
    uint gridX = hashedCellId % _GridWidth;
    uint gridY = (hashedCellId / _GridWidth) % _GridDepth;
    
    // Generate deterministic random values for the relative position within the cell
    // These values are ONLY based on thread ID and seed, not on cell position
    float relativeX = GetRandomFloat(id * 12345 + 1, _RandomSeed);
    float relativeY = GetRandomFloat(id * 12345 + 2, _RandomSeed);
    
    // Random offset is also generated deterministically
    float2 randomOffset = float2(0, 0);
    if (_RandomOffset > 0)
    {
        randomOffset.x = (GetRandomFloat(id * 12345 + 3, _RandomSeed) * 2 - 1) * _RandomOffset;
        randomOffset.y = (GetRandomFloat(id * 12345 + 4, _RandomSeed) * 2 - 1) * _RandomOffset;
    }
    
    // Calculate normalized bounds width and height using ORIGINAL unclamped bounds
    // This ensures grid cell consistency even when partially outside terrain
    float boundsWidth = _OriginalBoundsMax.x - _OriginalBoundsMin.x;
    float boundsHeight = _OriginalBoundsMax.z - _OriginalBoundsMin.z;
    
    // Calculate cell size in normalized coordinates
    float cellWidth = boundsWidth / _GridWidth;
    float cellHeight = boundsHeight / _GridDepth;
    
    // Calculate position with the grid cell
    float2 position;
    
    // Base position of this grid cell using ORIGINAL bounds for consistency
    float baseX = _OriginalBoundsMin.x + gridX * cellWidth;
    float baseY = _OriginalBoundsMin.z + gridY * cellHeight;
    
    // Final position = base position + relative position within cell + random offset
    position.x = baseX + relativeX * cellWidth + randomOffset.x * cellWidth;
    position.y = baseY + relativeY * cellHeight + randomOffset.y * cellHeight;
    
    // Check if the position is within the valid terrain bounds (0-1)
    // If outside terrain, mark as invalid by returning (0,0)
    if (position.x < 0 || position.x > 1 || position.y < 0 || position.y > 1)
        return float2(0, 0);
    
    // For positions that ARE within the terrain bounds (0-1), check if they're
    // actually within our clamped usable area
    if (position.x < _BoundsMin.x || position.x > _BoundsMax.x || 
        position.y < _BoundsMin.z || position.y > _BoundsMax.z)
    {
        // Position is within terrain but outside our usable area, invalidate it
        return float2(0, 0);
    }
    
    // Position is valid - no need to clamp since we already confirmed it's within bounds
    return position;
}

float GetTerrainHeight(float2 normPos)
{
    return _HeightmapTexture.SampleLevel(sampler_HeightmapTexture, normPos, 0).r * _TerrainParams.y * 2.0;
}

float3 GetTerrainNormal(float2 normPos)
{
    float3 normal = _NormalTexture.SampleLevel(sampler_NormalTexture, normPos, 0).xyz;
    return normalize(normal * 2 - 1); // Convert from 0-1 to -1-1 range
}

float GetTerrainSlope(float2 normPos)
{
    float3 normal = GetTerrainNormal(normPos);
    return degrees(acos(dot(normal, float3(0, 1, 0))));
}

bool CheckHeightConstraint(float height, uint constraintIndex)
{
    float2 constraint = _HeightConstraints[constraintIndex];
    return height >= constraint.x && height <= constraint.y;
}

bool CheckSlopeConstraint(float slope, uint constraintIndex)
{
    float2 constraint = _SlopeConstraints[constraintIndex];
    
    // Explicitly check the constraint values
    bool isValid = (slope >= constraint.x && slope <= constraint.y);
    
    // Add debug output in result.debugSlope later
    return isValid;
}

bool CheckMaskConstraint(float2 boundsNorm)
{
    float4 maskColor = _MaskTexture.SampleLevel(sampler_MaskTexture, boundsNorm, 0);
    
    // Use the actual threshold from MaskConstraint
    float maskValue = maskColor.r;
    
    // Compare with the threshold from the constraint
    return maskValue > _MaskConstraintThresholds[0];
}

bool CheckNoiseConstraint(float2 boundsNorm)
{
    // Get noise parameters
    float4 noiseParams = _NoiseConstraints[0]; // x: threshold, y: scale, z: offset, w: unused
    
    // Sample the noise texture
    float4 noiseColor = _NoiseTexture.SampleLevel(sampler_NoiseTexture, boundsNorm, 0);
    
    // Use grayscale value for comparison (average of RGB)
    float noiseValue = (noiseColor.r + noiseColor.g + noiseColor.b) / 3.0;
    
    // Fall back to procedural noise if the texture returns a zero value (might be a default white texture)
    if (noiseValue < 0.001f)
    {
        // Simple Perlin-like noise as fallback, but with added seed influence to make it deterministic
        float2 scaledPos = boundsNorm * noiseParams.y + float2(noiseParams.z + (_RandomSeed % 100) * 0.01, 
                                                              noiseParams.z + (_RandomSeed % 100) * 0.01);
        float2 i = floor(scaledPos);
        float2 f = frac(scaledPos);
        float2 u = f * f * (3.0 - 2.0 * f); // Smoothstep
        
        // Include random seed in the hash calculations
        uint seedOffset = _RandomSeed * 1103515245 + 12345; // Linear congruential generator
        
        // Generate 4 pseudo-random values using seed and position
        float n00 = frac(sin(dot(i, float2(127.1, 311.7)) + seedOffset * 0.0001) * 43758.5453);
        float n01 = frac(sin(dot(i + float2(0, 1), float2(127.1, 311.7)) + seedOffset * 0.0001) * 43758.5453);
        float n10 = frac(sin(dot(i + float2(1, 0), float2(127.1, 311.7)) + seedOffset * 0.0001) * 43758.5453);
        float n11 = frac(sin(dot(i + float2(1, 1), float2(127.1, 311.7)) + seedOffset * 0.0001) * 43758.5453);
        
        float nx0 = lerp(n00, n10, u.x);
        float nx1 = lerp(n01, n11, u.x);
        noiseValue = lerp(nx0, nx1, u.y);
    }
    
    // Check against threshold
    return noiseValue >= noiseParams.x;
}

bool CheckCollisionConstraint(float3 worldPos, float currentMinDistance, float objectScale)
{
    // If no placed objects, constraint is satisfied
    if (_PlacedObjectCount == 0)
        return true;
    
    // Use default if not specified
    float minDist = currentMinDistance > 0 ? currentMinDistance : _DefaultMinDistance;
    
    // Scale the minimum distance by the object's scale
    minDist *= objectScale;
    
    // Check against all placed objects
    for (uint p = 0; p < _PlacedObjectCount; p++)
    {
        // Get position from flattened array
        float3 objPos = float3(
            _PlacedObjectPositions[p*3],
            _PlacedObjectPositions[p*3+1],
            _PlacedObjectPositions[p*3+2]
        );
        
        // Get minimum distance for this object (already includes GlobalScale and that object's scale)
        float objMinDist = _MinimumDistances[p];
        
        // Use maximum of the two distances
        float requiredDist = max(minDist, objMinDist);
        
        // Calculate distance between points
        float dist = distance(worldPos, objPos);
        
        // If too close, fail the constraint
        if (dist < requiredDist)
            return false;
    }
    
    // All checks passed
    return true;
}

bool CheckLayerConstraint(float2 normPos)
{
    // If no layer constraints are specified, always return true
    if (_LayerConstraintCount == 0)
        return true;
    
    // Special case: if we have one entry and it's -1, it means the user specified
    // layer constraints but none of those layers were found in the terrain.
    // In this case, we should always fail the constraint
    if (_LayerConstraintCount == 1 && _LayerConstraintIndices[0] == -1)
        return false;
    
    // Sample alphamap at position
    float4 alphamap = _AlphamapTexture.SampleLevel(sampler_AlphamapTexture, normPos, 0);
    
    // Find the dominant layer index (0-3 for RGBA channels)
    int dominantLayerIndex = 0;
    float maxWeight = alphamap.r;
    
    if (alphamap.g > maxWeight) { 
        dominantLayerIndex = 1; 
        maxWeight = alphamap.g; 
    }
    if (alphamap.b > maxWeight) { 
        dominantLayerIndex = 2; 
        maxWeight = alphamap.b; 
    }
    if (alphamap.a > maxWeight) { 
        dominantLayerIndex = 3; 
        maxWeight = alphamap.a; 
    }
    
    // Check if the dominant layer is in our allowed layers
    for (uint k = 0; k < _LayerConstraintCount; k++)
    {
        if (_LayerConstraintIndices[k] == dominantLayerIndex)
            return true;
    }
    
    return false;
}

bool CheckAllConstraints(float2 normPos, float2 boundsNorm, float height, float slope, float3 worldPos, float minDistance, float objectScale)
{
    // Check mask constraint if texture provided
    if (!CheckMaskConstraint(boundsNorm))
        return false;
    
    // Check height constraints
    if (!CheckHeightConstraint(height, 0))
        return false;
    
    // Check slope constraints
    if (!CheckSlopeConstraint(slope, 0))
        return false;
    
    // Check noise constraints
    if (!CheckNoiseConstraint(boundsNorm))
        return false;
    
    // Check layer constraint
    if (!CheckLayerConstraint(normPos))
        return false;
    
    // Check collision constraint with object scale
    if (!CheckCollisionConstraint(worldPos, minDistance, objectScale))
        return false;
    
    return true;
}

[numthreads(64,1,1)]
void GeneratePositions(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    // Initialize result as invalid
    _Results[index].isValid = 0;
    _Results[index].normalAlignmentFactor = 0.0; // Initialize normal alignment factor
    
    // Skip if beyond the maximum number of objects
    if (_MaxObjectCount > 0 && index >= _MaxObjectCount)
        return;
    
    // Apply density-based filtering only if density is less than 1.0
    // Use a consistent hash value for density check - only based on thread ID and seed
    if (_Density < 0.99f && GetRandomFloat(index * 54321 + 9, _RandomSeed) > _Density)
        return;
    
    // Generate grid-based random position with hashing for better distribution
    float2 normPos = GetRandomPosition(index);
    
    // Skip if position is invalid (outside terrain or outside grid)
    // GetRandomPosition returns (0,0) for invalid positions
    if (normPos.x == 0 && normPos.y == 0)
        return;
    
    // Calculate position within bounds (0-1 relative to bounds, not terrain)
    float2 boundsNorm;
    
    // Calculate the aspect ratio of the bounds
    float boundsWidth = _OriginalBoundsMax.x - _OriginalBoundsMin.x;
    float boundsDepth = _OriginalBoundsMax.z - _OriginalBoundsMin.z;
    
    // Adjust for square aspect ratio (matching SplineAreaShape's adjustment)
    if (boundsWidth > boundsDepth)
    {
        // X is dominant, so we need to scale Z to match
        float center = (_OriginalBoundsMin.z + _OriginalBoundsMax.z) * 0.5;
        float halfSize = boundsWidth * 0.5;
        
        // Map Y (Z) coordinate properly to match the square aspect in the mask
        boundsNorm.x = (normPos.x - _OriginalBoundsMin.x) / boundsWidth;
        boundsNorm.y = (normPos.y - (center - halfSize)) / boundsWidth;
    }
    else
    {
        // Z is dominant, so we need to scale X to match
        float center = (_OriginalBoundsMin.x + _OriginalBoundsMax.x) * 0.5;
        float halfSize = boundsDepth * 0.5;
        
        // Map X coordinate properly to match the square aspect in the mask
        boundsNorm.x = (normPos.x - (center - halfSize)) / boundsDepth;
        boundsNorm.y = (normPos.y - _OriginalBoundsMin.z) / boundsDepth;
    }
    
    // Clamp to 0-1 range to ensure valid texture coordinates
    boundsNorm = clamp(boundsNorm, 0.0, 1.0);
    
    // Get terrain height and slope
    float height = GetTerrainHeight(normPos);
    float slope = GetTerrainSlope(normPos);
    
    // Get terrain normal for alignment
    float3 normal = GetTerrainNormal(normPos);
    
    // Choose prefab index - use consistent hash values
    uint prefabIndex = floor(GetRandomFloat(index * 98765 + 5, _RandomSeed) * _NumberOfGameObjects);
    if (prefabIndex >= _NumberOfGameObjects)
        prefabIndex = _NumberOfGameObjects - 1;
    
    // Get prefab-specific settings
    PrefabSettings settings = _PrefabSettings[prefabIndex];
    
    // Convert normalized to world position with Y offset
    float3 worldPos;
    worldPos.x = _TerrainPosition.x + normPos.x * _TerrainParams.x;
    worldPos.y = height + settings.yOffset;
    worldPos.z = _TerrainPosition.z + normPos.y * _TerrainParams.z;
    
    // Calculate random scale based on prefab settings - use consistent hash values
    float scale = lerp(settings.minScale, settings.maxScale, GetRandomFloat(index * 87654 + 6, _RandomSeed));
    
    // Calculate normal alignment factor (0-1) if normal alignment is enabled
    float normalAlignmentFactor = 0.0;
    if (settings.alignToNormal > 0)
    {
        normalAlignmentFactor = lerp(settings.minNormalAlignment, settings.maxNormalAlignment, 
                                     GetRandomFloat(index * 76543 + 8, _RandomSeed));
    }
    
    // Check all constraints and mark if slope constraint fails
    bool allConstraintsValid = true;
    bool slopeValid = CheckSlopeConstraint(slope, 0);
    
    // Store the raw slope with a special marker if slope constraint fails
    if (!slopeValid)
    {
        _Results[index].normalAlignmentFactor = -10.0; // Use this field for debugging since we're not using debugSlope anymore
        allConstraintsValid = false;
    }
    
    // Check other constraints
    if (!CheckHeightConstraint(height, 0) || 
        !CheckMaskConstraint(boundsNorm) ||
        !CheckNoiseConstraint(boundsNorm) ||
        !CheckLayerConstraint(normPos) ||
        !CheckCollisionConstraint(worldPos, settings.minimumDistance, scale))
    {
        allConstraintsValid = false;
    }
    
    if (allConstraintsValid)
    {
        // Store valid result
        _Results[index].position = worldPos;
        _Results[index].scale = scale;
        _Results[index].rotation = 0;
        if (settings.randomYRotation > 0)
        {
            _Results[index].rotation = lerp(settings.minRotation, settings.maxRotation, 
                                           GetRandomFloat(index * 65432 + 7, _RandomSeed));
        }
        _Results[index].prefabIndex = prefabIndex;
        _Results[index].isValid = 1;
        _Results[index].normalAlignmentFactor = normalAlignmentFactor;
        _Results[index].normal = normal;
    }
}

// Kernel for filtering object collisions
[numthreads(64,1,1)]
void FilterObjectCollisions(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    // Skip if beyond input results count
    if (index >= _InputResultsCount)
        return;
    
    // Skip invalid objects
    if (_Results[index].isValid == 0)
        return;
    
    // Get this object's position, scale, and prefab index
    float3 position = _Results[index].position;
    float scale = _Results[index].scale;
    uint prefabIndex = _Results[index].prefabIndex;
    
    // Get minimum distance for this object
    PrefabSettings settings = _PrefabSettings[prefabIndex];
    float minDist = settings.minimumDistance;
    if (minDist <= 0)
        minDist = _DefaultMinDistance;
    
    // Scale the minimum distance by the object's scale, slightly reduced for the filtering pass
    // to make filtering less aggressive
    minDist *= scale * 0.8; // Reduce by 20% to prevent over-filtering
    
    // Check against all other valid objects we've seen so far
    bool validPosition = true;
    
    // First, check against existing objects (from previous iterations)
    // This is already done in the GeneratePositions kernel via CheckCollisionConstraint
    
    // Next, check against other objects already in the filtered results buffer
    uint validCount = 0;
    InterlockedAdd(_ValidCount[0], 0, validCount); // Atomic read of current valid count
    
    // Early exit for the first object (always valid and nothing to check against)
    if (validCount == 0)
    {
        // This is the first valid object, add it
        uint slotIndex = 0;
        InterlockedAdd(_ValidCount[0], 1, slotIndex);
        
        if (slotIndex < _MaxResults)
        {
            _FilteredResults[slotIndex] = _Results[index];
        }
        return;
    }
    
    // Check against previously filtered objects
    for (uint j = 0; j < validCount && validPosition; j++)
    {
        // Skip if the other object is invalid (should not happen, but just in case)
        if (_FilteredResults[j].isValid == 0)
            continue;
            
        // Get the other object's position, scale, and minimum distance
        float3 otherPos = _FilteredResults[j].position;
        float otherScale = _FilteredResults[j].scale;
        uint otherPrefabIndex = _FilteredResults[j].prefabIndex;
        
        // Skip distance check for far away objects (optimization)
        float3 diff = position - otherPos;
        float sqrDist = dot(diff, diff);
        if (sqrDist > 100.0) // Skip if more than 10 units away
            continue;
        
        // Get other object's minimum distance
        PrefabSettings otherSettings = _PrefabSettings[otherPrefabIndex];
        float otherMinDist = otherSettings.minimumDistance;
        if (otherMinDist <= 0)
            otherMinDist = _DefaultMinDistance;
            
        // Scale by object's scale, also reduced for filtering pass
        otherMinDist *= otherScale * 0.8; // Reduce by 20% 
        
        // Use maximum of the two distances
        float requiredDist = max(minDist, otherMinDist);
        
        // Calculate squared distance for performance
        float sqrRequiredDist = requiredDist * requiredDist;
        
        // Check distance
        if (sqrDist < sqrRequiredDist)
        {
            validPosition = false;
        }
    }
    
    // If position is valid, add to filtered results
    if (validPosition)
    {
        // Atomically increment valid count to get our "slot"
        uint slotIndex = 0;
        InterlockedAdd(_ValidCount[0], 1, slotIndex);
        
        // Check if we're still under the max objects limit
        if (slotIndex < _MaxResults)
        {
            // Copy result to filtered array
            _FilteredResults[slotIndex] = _Results[index];
        }
    }
} 